import random

class SudokuSolver:
    @staticmethod
    def sudokuSolver():
        board = SudokuSolver.sudokuGenerator(3)
        SudokuSolver.printSudoku(board)

    @staticmethod
    def sudokuGenerator(base=3):
        """
        Generate a Solved Sudoku Puzzle
        
        Source: https://stackoverflow.com/questions/45471152/how-to-create-a-sudoku-puzzle-in-python

        Returns:
            list (list (int)): The solved sudoku Puzzle
        """
        side = base ** 2

        def pattern(r, c):
            """
                The idea here is that each row is generated by the base of the matrix. (if matrix is 9x9 then base is 3).
                the first row is randomally generated, the second row is an offset of the first row with a randomized base.
                for example:
                if we generate the matrix:
                [6, 5, 2, 7, 4, 3, 1, 9, 8]
                [3, 4, 7, 8, 1, 9, 5, 6, 2]
                [9, 1, 8, 2, 5, 6, 4, 3, 7]
                [7, 9, 1, 5, 6, 8, 3, 2, 4]
                [8, 6, 5, 4, 3, 2, 9, 7, 1]
                [2, 3, 4, 1, 9, 7, 6, 8, 5]
                [4, 7, 9, 6, 8, 1, 2, 5, 3]
                [5, 2, 3, 9, 7, 4, 8, 1, 6]
                [1, 8, 6, 3, 2, 5, 7, 4, 9]
                
                we can see the the first 3 numbers in the first row will be a randomized version of the last 3 numbers in the second row
                and the middle 3 numbers in the third row. (there are 2 more groups in 1-3 rows that fit this description).
                
                (4-6) and (7-9) rows are two more clusters that are similar to (1-3) rows.
                
                but each cluster is also offseted randomally.
                
                the first part: base*(r % base) is to get the base randomization of the current row and use it to build the offest.
                
                note that every 3 numbers (every base numbers) are always clogged together as a result of the generation of rows and cols.
                
                the second part: r//base is to get the current cluster and use it to build the offest.
                
                and the third part: + c is to add the random numbers we had earlier
                
                (of course % side to not get over the valid numbers.)
                
            Args:
                r ([type]): [description]
                c ([type]): [description]

            Returns:
                [type]: [description]
            """
            res = base*(r % base)
            res += r//base
            res += c
            res %= side
            return res

        def shuffle(s): return random.sample(s, len(s))
        rBase = range(base)
        rows = [g*base + r for g in shuffle(rBase) for r in shuffle(rBase)]
        cols = [g*base + c for g in shuffle(rBase) for c in shuffle(rBase)]
        nums = shuffle(range(1, side + 1))
        board = [[nums[pattern(r, c)] for c in cols] for r in rows]
        
        squares = side * side
        empties = squares * 3 // 4
        for p in random.sample(range(squares), empties):
            board[p // side][p % side] = 0

        return board
    
    @staticmethod
    def printSudoku(board):
        for line in board:
            print("[" + " ".join(f"{n or '.':{len(str(len(board)))}}" for n in line) + "]")

if __name__ == "__main__":
    SudokuSolver.sudokuSolver()
